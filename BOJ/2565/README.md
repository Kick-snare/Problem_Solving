BOJ 2565번 전깃줄

![](https://i.ibb.co/yd21TLf/image.png)

문제 접근
---
전봇대 A와 B의 전깃줄이 교차하지 않도록 없애야하는 전깃줄의 최소 갯수를 구해야한다.
이는 A와 B의 전깃줄 중 교차하지 않는 것의 최대 갯수를 구해 전깃줄의 갯수에서 뺴면 된다.

A와 B는 전깃줄로 연결되어 있다.
이를 배열의 형태로 저장할 때 인덱스 A가 값인 B를 가르키고 있는 형태로 표현 가능하다.

예시로 주어진 그림은 배열로 저장하면 아래와 같을 것이다.

|index|1|2|3|4|5|6|7|8|9|10|
|-|-|-|-|-|-|-|-|-|-|-|
|pole[ i ]|8|2|9|1|0|4|6|0|7|10|

#### dp 테이블 만들기

완전 탐색을 하기에는 너무 많은 자원이 요구되므로 반복적인 계산을 줄이기 위하여 dp테이블을 만들어 중간중간 값을 저장하고, 꺼내어 쓸 것이다.

dp[i] 에는 0부터 i번째까지 배열을 가지고 문제에서 요구하는 알고리즘의 값을 메모할 것이다.
즉, dp[i]는 i번째까지의 교차하지 않는 전깃줄의 최대 갯수를 저장한다.

가장 큰 인덱스(A)의 크기를 가진 1차원 배열을 선언한다.

#### 점화식 세우기

교차하지 않는 전깃줄을 찾기 위해서는 두 전깃줄을 비교하며 탐색해야한다.
그러므로 이중반복문을 돌며 i와 j의 값을 비교한다.

A와 B의 두 전깃줄(`i` , `j`)이 교차하지 않기 위해서는 다음 조건이 필요하다.
>  `i` < `j` 일때, `pole[i]` < `pole[j]`

인덱스(A)가 크면 가르키는 값(B)도 커야 교차하지 않는다.

이중 반복문을 돌며, i번째 원소에서는 0부터 i번째 전까지의 원소 중 `pole[i]` < `pole[j]`인 값을 찾으면, 위에서 말한 조건과 일치하므로 교차하지 않다고 말할 수 있다.

일치하는 값들 중 dp[j]가 가장 큰 값에서 전깃줄 i 를 포함하여 1을 더하면 
dp[i], 즉 i번째 원소까지의 교차하지 않는 전깃줄의 최대 갯수이다.

#### LIS

이 조건을 생각해보면 [LIS 알고리즘](https://uzun.dev/2021-01/BOJ11053)과 조건이 똑같다.

- 인덱스가 크면 (순서고정) 값도 커야한다(증가)
- i번째 원소에서 i보다 작은 j번째 원소에서 dp에 저장한 lis의 최댓값에 1을 더해 dp[i]에 저장

사실 말만 다르지 똑같은 문제라고 볼 수 있다.

문제 풀이
---
```cpp
int main(){
    
    int N, tmp, max_idx = 0;
    int pole[501] = {0,}, dp[501] = {0,};

    cin >> N;

    for(int i=0;i<N;i++) {
        cin >> tmp;
        cin >> pole[tmp];
        max_idx = max(max_idx, tmp);
    }

    for(int i=0;i<max_idx;i++) 
        if(pole[i+1]) dp[i+1] = 1;

    for(int i=1;i<=max_idx;i++)
        for(int j=1;j<i;j++)
            if (pole[i] > pole[j])
                dp[i] = max(dp[i], dp[j] + 1);
        
    cout << N - *max_element(dp,dp+501);

    return 0;
}
```

결과 
---
<img src="https://i.ibb.co/gm99K1L/image.png" alt="image" border="0">