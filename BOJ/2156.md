BOJ 2156번 포도주 시식
<img src="https://i.ibb.co/m6cjC1J/image.png" alt="image" border="0">

문제 접근
---
> - 포도주가 담긴 잔을 골라, 최대한 많은 양의 포도주를 마셔야한다.
> - 단, 포도주는 연속하여 3잔을 고를 수 없다.

경우의 수를 계산하기에는 O(2^n) 으로 밑도 끝고 없이 커지므로 dp 테이블을 짜서 점화식을 찾아야 할 것이다.

dp문제라면, 누적합을 구하며 전과 후의 연관관계를 찾아 내야 한다. 
문제는 어떻게 찾아 낼 것이냐인데...

일단 조건에서 포도주를 연속해서 마실 수 없다고 하였으므로,
- [1] 이전의 잔을 마시지 않았을 때
- [2] 이전의 잔을 연속 한번 마셨을 때
- [3] 이전의 잔을 연속 두번 마셨을 때

의 경우는 이후에 결과값에 유의미한 차이를 만들어 내니까, 따로 나누어 카운팅한다.

>[1]의 경우 이전의 값과 상관없이 언제든 마시지 않을 수 있으므로 >이전값에서 [1][2][3] 중 가장 큰 누적합을 저장한다.
>
>[2]의 경우 이전의 [1]에서 해당 잔의 양을 더한 값을 저장한다.
>
>[3]의 경우 이전의 [2]에서 해당 잔의 양을 더한 값을 저장한다.

문제 풀이
---
```cpp
int main(){
    int wine[100001] = {0,};
    int dp[10001][3] = {0,};
    int N;

    cin >> N;

    for(int i=0;i<N;i++) cin >> wine[i+1];
    
    for(int i=1;i<=N;i++){
        dp[i][0] = max({dp[i-1][0],dp[i-1][1],dp[i-1][2]});
        dp[i][1] = dp[i-1][0] + wine[i];
        dp[i][2] = dp[i-1][1] + wine[i];
    }

    cout << max({dp[N][0],dp[N][1],dp[N][2]});

    return 0;
}
```

- 포도주 잔들의 양을 저장할 배열 `wine`
- [1][2][3] 경우의 누적합을 저장할 저장공간 `dp`
  
문제 접근에서 설명한대로 점화식을 세워 dp를 채우고,
N번째에서 [1][2][3] 중 가장 큰 누적합이 최대로 마실 수 있는 포도주 양의 누적합이다.

결과
---
<img src="https://i.ibb.co/Q6M6k3S/image.png" alt="image" border="0">