BOJ 1912번 연속합
<img src="https://i.ibb.co/6Bd7z42/image.png" alt="image" border="0">

문제 접근
---
주어지는 배열에서 연속되는 수들의 합 중 가장 큰 합을 출력해야한다.

배열 [10, -4, 3, 1, 5, 6, -35, 12, 21, -1]을 예로 들어 보자.

완전 탐색하기에는 시간제한이 있으므로 시간 초과가 뜰 것같다.
그러므로 주어지는 조건을 만족하는 부분 배열을 저장하기 위한 dp 테이블을 하나 만든다.

`dp[i]` 의 정의를 **0번째 부터 i번째까지**, **i번째 수를 포함**하는 **최대연속수합**이라고 하자.

주어진 배열을 순회하며 dp를 채워보자.
|i|0||||||||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10||||||||||

i=0 일때는 
`dp[0]`는 수가 하나 밖에 없으므로 당연히 `arr[0]`이다.

|i|0|1|||||||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|||||||||

i=1 이면
dp[i]는 -4 하나를 고르는 것보단 arr[0]와 연속으로 더하는게 크다.
즉, **`-4` < `10` + `-4`** 이므로 `dp[1]` = 6

|i|0|1|2||||||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9||||||||

i=2 이면
마찬가지로 연속으로 더하는게 크니까 이전의 최대연속수합인 `dp[2]`에 `arr[3]`를 더하면 `dp[3]`이라고 볼 수 있다.
**`3` < `10` + `-4` + `3`** 이므로 `dp[1]` = 9

2가지 케이스로 볼때,
만약 `i`번째 수보다 `i-1`번째 최대연속수합과 해당 수를 더한 합이 더 크다면 후자가 `i`번째 최대연속수합이라고 볼 수 있다.

즉, `if(arr[i] < arr[i] + dp[i-1]) dp[i] = dp[i-1] + arr[i]`이다.

|i|0|1|2|3|||||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|||||||

|i|0|1|2|3|4||||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15||||||

|i|0|1|2|3|4|5|||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15|21|||||

|i|0|1|2|3|4|5|6||||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15|21|-14||||


i=6 일때 까지도 똑같이 흘러가지만, i=7 일때를 보자.

|i|0|1|2|3|4|5|6|7|||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15|21|-14|12|||

여기서는 `dp[i-1]`이 음수여서 `dp[i-1]` + `arr[i]`보다 단독으로 `arr[i]`만 선택한 것이 더 크다.
그러므로 i=7에서는 연속합을 끊고 `dp[i]`에 `arr[i]`를 채운다.

즉, `if(arr[i] > arr[i] + dp[i-1]) dp[i] = arr[i]`이다.

|i|0|1|2|3|4|5|6|7|8||
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15|21|-14|12|33||

|i|0|1|2|3|4|5|6|7|8|9|
|-|-|-|-|-|-|-|-|-|-|-|
|arr[i]|10|-4|3|1|5|6|-35|12|21|-1|
|dp[i]|10|6|9|10|15|21|-14|12|33|32|

dp 테이블을 모두 채우고 나면 `dp[i]`중 가장 큰 값이 배열 `arr`의 가장 큰 연속 수들의 합이다.

문제 풀이
---
```cpp
int main(){
    int N;
    int arr[100000],dp[100000];

    cin >> N;

    for(int i=0;i<N;i++) cin >> arr[i];

    dp[0] = arr[0];

    for(int i=1;i<N;i++){
        if(dp[i-1] < 0) dp[i] = arr[i];
        else dp[i] = dp[i-1] + arr[i];
    }
    
    cout << *max_element(dp,dp+N);

    return 0;
}
```

결과
---
<img src="https://i.ibb.co/YNNYbtd/image.png" alt="image" border="0">


dp문제에 익숙하지 않아 dp 테이블을 어떻게 잡을 것인지, 정확히 어떠한 값을 저장하여, 불러와 쓸 것인지에 기준을 세우고 점화식을 발견하는데 어려움이 많다. 1912 연속합 문제도 로직은 간단하지만 이를 찾아내지 못해 많이 헤매었다.
dp문제에 대한 집중적인 공부와 유형파악이 필요한 것 같다.