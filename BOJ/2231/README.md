
# 백준 2231번 문제

---

### 문제 해결 날짜 및 시간

- 2020년 12월 29일
- 메모리 : 2200KB
- 시간 : 0ms

---

### 접근 방식

```c++
#include <iostream>
#include <cmath>
using namespace std;


int main(){
    int N, Nnum, count, sum, min= 0;
    int num[7];

    cin >> N;

    for(int i=1; i<64; i++){
        sum, count = 0;
        Nnum = N-i;
        
        fill_n(num, 7, -1);
        // 각자리 수를 저장하는 num배열을 -1로 초기화

        while (Nnum >= 1){
            // num[i]에 낮은 자리 수부터 저장
            num[count] = Nnum%10;
            Nnum /= 10;
            count++;
        }

        for(int j=0; num[j] != -1; j++)
            sum += num[j]*(pow(10, j) + 1);
        // 아래 공식에 따라 각자리수*(10^(자리수j)+1)를 sum 에 누적합산
        
        if(sum == N) min = N-i;
        //sum이 원값과 같다면 min 최신화
    }

    cout << min;

    return 0;
}
```

 자연수 N의 분해합은 N과 N을 이루는 각 자리 수들의 합이다. N을 알고 있을 때 N의 분해합을 구하는 알고리즘은 매우 쉽지만 이는 반대로 분해합을 주고 어떠한 자연수를 구했을 때 이 값이 나오는 가를 역으로 찾아야 한다.
 
 n의 자리수의 자연수 N의 분해합을 구하는 공식은 다음과 같다. 
![공식](https://i.ibb.co/pw6jxJZ/2020-12-29-11-51-37.png)
 딱 봐도 역으로 분해 합의 값만 알고 역으로 구하기에는 너무 어려우므로, 여러가지 수를 대입해봐야 할 것이다.

모든 수를 대입해 볼 수는 없으므로 값에 제한을 두었다. 문제에서 주어진 입력값은 최소 한자리 수 부터 일곱자리 수까지 주어진다. 분해합은 본랫값에 각자리 수를 더하므로, 원값과 최대 9(각자리 최댓값) * 7(자리수) = 63이상 차이나지 않는다.

일단 1차로 `입력값-1` ~ `입력값-63` 까지 반복 돌리고
각 자리수를 저장하기 위하여 `num[7]` 배열을 선언하고 탈출조건을 위해 -1로 초기화 했다. 각 자리수가 저장된 `num`배열은 위 공식에 따라 각자의 분해합을 구하게 된다. 구해진 분해합은 입력값과 같다면 `min`값은 `입력값-i`로 대체된다. 1차 반복문의 `N-i`값이 내림차 순이기에 `min`값과 비교하지 않아도 된다.

마지막에는 `min`값을 출력한다.

