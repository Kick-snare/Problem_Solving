
# 2021년 01월 05일 화요일
# 백준 10989번 [수 정렬하기 3]
### https://www.acmicpc.net/problem/10989

---

### 문제 해결 날짜 및 시간

- 2021년 1월 4일 22시
- 메모리 : 2016KB
- 시간 : 1596ms

---

### 접근 방식

```cpp
#define MAX 10000

int main(){
	ios_base :: sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
    // cin cout 입출력 속도를 높이기 위한 코드

	int N,tmp;
	int num[MAX] = {0,};
    // N개의 자연수는 모두 10000이하이므로 일단 10000크기 배열을 만든다

	cin >> N;

	for(int i=0;i<N;i++){
		cin >> tmp;
		num[tmp-1]++;
        // 수가 들어올 때마다 수를 인덱스로 생각하여 배열값에 1일 더해준다
	}

	for(int i=0;i<MAX;i++){
		if(num[i]==1) cout << i+1 << "\n";
		else if(num[i])
			for(int j=0;j<num[i];j++)
				cout << i+1 << "\n";

        // 수를 인덱스로 생각하고 들어온 만큼 카운트 해주었기에 이미 배열 시작부터 끝까지 카운팅 된만큼 인덱스를 출력해준다.
	}

	return 0;
}
```

이 문제에서는 들어온 N개의 수를 정렬해주면 되는 간단한 문제이다. 하지만 메모리 제한과 시간 제한이 매우매우매우 제한적이라 일반적인 정렬로는 도저히 풀 수 없다. 

처음엔 merge 정렬 또는 heap정렬로 풀어볼려고 하였으나 어림도 없는 걸 깨닫고 다른 코드를 참고해 `Counting Sort` 계수정렬로 풀었다.

계수정렬은 애초에 다른 정렬들과 다르게 비교를 하지않는다. 주어진 수 N개만큼의 크기를 가진 배열 num을 선언하고 값이 들어올 때 마다 각 인덱스에 맞는 값을 ++ 해준다.

그리고 배열 시작부터 끝까지 배열 값만큼 인덱스를 출력해주면 순서대로 정렬되어 나온다.

계수정렬의 시간복잡도는 `O(n + k)`으로 이 문제의 경우 최댓값인 `k`가 10000. `O(N+10000)` 으로 굉장히 빠르지만 최댓값과 최소값의 범위가 작다는 제한된 상황에서만 유리하다. 범위가 넓어지면 메모리를 많이 잡아먹으며 쓸때없는 반복이 많아진다.
